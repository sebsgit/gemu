#include "test_base.h"
#include <string.h>

/* 
  __global__ void kernel(int * datai, unsigned * datau, int rem){
		datai[threadIdx.x] = threadIdx.x % rem;
		datau[threadIdx.x] = (unsigned)(threadIdx.x) % (unsigned)rem;
	} 
*/

int main(){
	init_test();
	const std::string test_source =
	"//\n"
	"// Generated by NVIDIA NVVM Compiler\n"
	"//\n"
	"// Compiler Build ID: CL-19856038\n"
	"// Cuda compilation tools, release 7.5, V7.5.17\n"
	"// Based on LLVM 3.4svn\n"
	"//\n"
	"\n"
	".version 4.3\n"
	".target sm_20\n"
	".address_size 64\n"
	"\n"
	"	// .globl	_Z6kernelPiPji\n"
	"\n"
	".visible .entry kernel(\n"
	"	.param .u64 _Z6kernelPiPji_param_0,\n"
	"	.param .u64 _Z6kernelPiPji_param_1,\n"
	"	.param .u32 _Z6kernelPiPji_param_2\n"
	")\n"
	"{\n"
	"	.reg .b32 	%r<4>;\n"
	"	.reg .b64 	%rd<8>;\n"
	"\n"
	"\n"
	"	ld.param.u64 	%rd1, [_Z6kernelPiPji_param_0];\n"
	"	ld.param.u64 	%rd2, [_Z6kernelPiPji_param_1];\n"
	"	ld.param.u32 	%r1, [_Z6kernelPiPji_param_2];\n"
	"	cvta.to.global.u64 	%rd3, %rd2;\n"
	"	cvta.to.global.u64 	%rd4, %rd1;\n"
	"	mov.u32 	%r2, %tid.x;\n"
	"	rem.u32 	%r3, %r2, %r1;\n"
	"	mul.wide.u32 	%rd5, %r2, 4;\n"
	"	add.s64 	%rd6, %rd4, %rd5;\n"
	"	st.global.u32 	[%rd6], %r3;\n"
	"	add.s64 	%rd7, %rd3, %rd5;\n"
	"	st.global.u32 	[%rd7], %r3;\n"
	"	ret;\n"
	"}\n"
	"\n"
	"\n"
	;
	CUmodule modId = 0;
	CUfunction funcHandle = 0;
	cu_assert(cuModuleLoadData(&modId, test_source.c_str()));
	cu_assert(cuModuleGetFunction(&funcHandle, modId, "kernel"));
	int rem = 37;
	int size = 150;
	int values[size];
	unsigned values_u[size];
	CUdeviceptr devValuesI, devValuesU;
	memset(values, 0, size * sizeof(values[0]));
	memset(values_u, 0, size * sizeof(values_u[0]));
	cu_assert(cuMemAlloc(&devValuesI, sizeof(int) * size));
	cu_assert(cuMemAlloc(&devValuesU, sizeof(unsigned) * size));
	void * params[] = {&devValuesI, &devValuesU, &rem};
	auto result = cuLaunchKernel(funcHandle, size,1,1, size,1,1, 0,0, params, nullptr);
	cu_assert(result);
	cu_assert(cuMemcpyDtoH(values, devValuesI, sizeof(int) * size));
	cu_assert(cuMemcpyDtoH(values_u, devValuesU, sizeof(unsigned) * size));
	cu_assert(cuMemFree(devValuesI));
	cu_assert(cuMemFree(devValuesU));
	cu_assert(cuModuleUnload(modId));
	for (int i=0 ; i<size ; ++i){
		std::cout << values[i] << ' ' << values_u[i] << "\n";
	}
	return 0;
}
